扩展思路
1）除了本教程中介绍的工具，还可以开发更多实用的工具，比如：
邮件发送：实现给用户发送邮件的功能
时间工具：获取当前时间日期等
数据库操作：查询、插入、更新和删除数据
2）优化 PDF 生成工具，将生成的文件上传到对象存储，能够提供可访问的文件 URL 地址返回给用户。
实现思路：保存文件到本地修改为保存到对象存储即可，还可以结合 “立即返回” 特性，避免额外调用 AI 大模型。
3）尝试自己控制工具的执行，并补充日志记录信息，提高应用的可观测性。
实现思路：利用 ToolCallingManager 手动控制工具执行流程
4）学习了这么多 Spring AI 的特性后，尝试自己开发一个新的特性。比如 “文件解析能力”，允许用户上传 PDF 文件，通过程序解析出来后提供给 AI 作为上下文。


# 扩展功能完整实现指南

## 1️⃣ 邮件发送工具

### 步骤1：添加依赖到 pom.xml

```xml
<!-- 邮件发送功能依赖 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-mail</artifactId>
</dependency>
```

### 步骤2：配置邮件服务器（application.yml）

```yaml
spring:
  mail:
    # 邮件服务器地址（以QQ邮箱为例）
    host: smtp.qq.com
    # SMTP端口号
    port: 587
    # 发件人邮箱账号
    username: your-email@qq.com
    # 邮箱授权码（不是登录密码）
    password: your-authorization-code
    # 邮件协议
    protocol: smtp
    # 默认编码
    default-encoding: UTF-8
    properties:
      mail:
        smtp:
          # 启用SMTP认证
          auth: true
          # 启用STARTTLS加密
          starttls:
            enable: true
            required: true
          # 连接超时时间（毫秒）
          connectiontimeout: 5000
          # 读取超时时间（毫秒）
          timeout: 5000
          # 写入超时时间（毫秒）
          writetimeout: 5000
```

### 步骤3：创建邮件发送工具类

```java
package com.zpark.zcwaiagent.tools;

import org.springframework.ai.tool.annotation.Tool;
import org.springframework.ai.tool.annotation.ToolParam;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;

import jakarta.mail.MessagingException;
import jakarta.mail.internet.MimeMessage;

/**
 * 邮件发送工具类
 * 提供发送简单文本邮件和HTML邮件的功能
 */
public class EmailSendingTool {

    // Spring提供的邮件发送器，用于发送邮件
    private final JavaMailSender mailSender;
    
    // 从配置文件中读取发件人邮箱地址
    @Value("${spring.mail.username}")
    private String fromEmail;

    /**
     * 构造函数，注入邮件发送器
     * @param mailSender Spring的邮件发送器
     */
    public EmailSendingTool(JavaMailSender mailSender) {
        // 将传入的邮件发送器赋值给成员变量
        this.mailSender = mailSender;
    }

    /**
     * 发送简单文本邮件
     * @param to 收件人邮箱地址
     * @param subject 邮件主题
     * @param content 邮件正文内容
     * @return 发送结果信息
     */
    @Tool(description = "Send a simple text email to specified recipient")
    public String sendSimpleEmail(
            @ToolParam(description = "Recipient email address") String to,
            @ToolParam(description = "Email subject") String subject,
            @ToolParam(description = "Email content") String content) {
        
        try {
            // 创建简单邮件消息对象
            SimpleMailMessage message = new SimpleMailMessage();
            // 设置发件人邮箱地址
            message.setFrom(fromEmail);
            // 设置收件人邮箱地址
            message.setTo(to);
            // 设置邮件主题
            message.setSubject(subject);
            // 设置邮件正文内容
            message.setText(content);
            
            // 发送邮件
            mailSender.send(message);
            
            // 返回成功信息
            return "Email sent successfully to: " + to;
            
        } catch (Exception e) {
            // 捕获异常并返回错误信息
            return "Failed to send email: " + e.getMessage();
        }
    }

    /**
     * 发送HTML格式邮件
     * @param to 收件人邮箱地址
     * @param subject 邮件主题
     * @param htmlContent HTML格式的邮件内容
     * @return 发送结果信息
     */
    @Tool(description = "Send an HTML email to specified recipient")
    public String sendHtmlEmail(
            @ToolParam(description = "Recipient email address") String to,
            @ToolParam(description = "Email subject") String subject,
            @ToolParam(description = "HTML content of the email") String htmlContent) {
        
        try {
            // 创建MIME类型的邮件消息对象，支持HTML格式
            MimeMessage mimeMessage = mailSender.createMimeMessage();
            // 创建邮件助手对象，用于设置邮件属性
            MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true, "UTF-8");
            
            // 设置发件人邮箱地址
            helper.setFrom(fromEmail);
            // 设置收件人邮箱地址
            helper.setTo(to);
            // 设置邮件主题
            helper.setSubject(subject);
            // 设置邮件内容，第二个参数true表示这是HTML格式
            helper.setText(htmlContent, true);
            
            // 发送邮件
            mailSender.send(mimeMessage);
            
            // 返回成功信息
            return "HTML email sent successfully to: " + to;
            
        } catch (MessagingException e) {
            // 捕获邮件消息异常并返回错误信息
            return "Failed to send HTML email: " + e.getMessage();
        }
    }

    /**
     * 发送带附件的邮件
     * @param to 收件人邮箱地址
     * @param subject 邮件主题
     * @param content 邮件正文内容
     * @param attachmentPath 附件文件路径
     * @return 发送结果信息
     */
    @Tool(description = "Send an email with attachment to specified recipient")
    public String sendEmailWithAttachment(
            @ToolParam(description = "Recipient email address") String to,
            @ToolParam(description = "Email subject") String subject,
            @ToolParam(description = "Email content") String content,
            @ToolParam(description = "Path to the attachment file") String attachmentPath) {
        
        try {
            // 创建MIME类型的邮件消息对象
            MimeMessage mimeMessage = mailSender.createMimeMessage();
            // 创建邮件助手对象，第二个参数true表示支持多部分（附件）
            MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true, "UTF-8");
            
            // 设置发件人邮箱地址
            helper.setFrom(fromEmail);
            // 设置收件人邮箱地址
            helper.setTo(to);
            // 设置邮件主题
            helper.setSubject(subject);
            // 设置邮件正文内容
            helper.setText(content);
            
            // 创建文件对象，指向附件文件
            java.io.File file = new java.io.File(attachmentPath);
            // 检查文件是否存在
            if (file.exists()) {
                // 添加附件，第一个参数是附件在邮件中显示的名称
                helper.addAttachment(file.getName(), file);
            } else {
                // 文件不存在，返回错误信息
                return "Attachment file not found: " + attachmentPath;
            }
            
            // 发送邮件
            mailSender.send(mimeMessage);
            
            // 返回成功信息
            return "Email with attachment sent successfully to: " + to;
            
        } catch (MessagingException e) {
            // 捕获邮件消息异常并返回错误信息
            return "Failed to send email with attachment: " + e.getMessage();
        }
    }
}
```

------

## 2️⃣ 时间工具

### 创建时间工具类（无需额外依赖）

```java
package com.zpark.zcwaiagent.tools;

import org.springframework.ai.tool.annotation.Tool;
import org.springframework.ai.tool.annotation.ToolParam;

import java.time.*;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.time.temporal.ChronoUnit;

/**
 * 时间日期工具类
 * 提供获取当前时间、日期格式化、时间计算等功能
 */
public class DateTimeTool {

    /**
     * 获取当前日期和时间
     * @param format 日期时间格式，如 "yyyy-MM-dd HH:mm:ss"
     * @return 格式化后的当前日期时间字符串
     */
    @Tool(description = "Get current date and time in specified format")
    public String getCurrentDateTime(
            @ToolParam(description = "Date format pattern, e.g., yyyy-MM-dd HH:mm:ss") String format) {
        
        try {
            // 获取当前日期时间对象
            LocalDateTime now = LocalDateTime.now();
            // 创建日期时间格式化器，使用传入的格式
            DateTimeFormatter formatter = DateTimeFormatter.ofPattern(format);
            // 格式化当前时间并返回
            return now.format(formatter);
            
        } catch (Exception e) {
            // 格式错误时返回错误信息
            return "Invalid date format: " + e.getMessage();
        }
    }

    /**
     * 获取当前日期（不含时间）
     * @return 当前日期，格式为 yyyy-MM-dd
     */
    @Tool(description = "Get current date in yyyy-MM-dd format")
    public String getCurrentDate() {
        // 获取当前日期对象
        LocalDate today = LocalDate.now();
        // 转换为字符串并返回
        return today.toString();
    }

    /**
     * 获取当前时间（不含日期）
     * @return 当前时间，格式为 HH:mm:ss
     */
    @Tool(description = "Get current time in HH:mm:ss format")
    public String getCurrentTime() {
        // 获取当前时间对象
        LocalTime now = LocalTime.now();
        // 创建时间格式化器
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("HH:mm:ss");
        // 格式化当前时间并返回
        return now.format(formatter);
    }

    /**
     * 计算两个日期之间的天数差
     * @param startDate 开始日期，格式为 yyyy-MM-dd
     * @param endDate 结束日期，格式为 yyyy-MM-dd
     * @return 天数差（正数表示endDate在startDate之后）
     */
    @Tool(description = "Calculate the number of days between two dates")
    public String calculateDaysBetween(
            @ToolParam(description = "Start date in yyyy-MM-dd format") String startDate,
            @ToolParam(description = "End date in yyyy-MM-dd format") String endDate) {
        
        try {
            // 解析开始日期字符串为LocalDate对象
            LocalDate start = LocalDate.parse(startDate);
            // 解析结束日期字符串为LocalDate对象
            LocalDate end = LocalDate.parse(endDate);
            // 计算两个日期之间的天数差
            long days = ChronoUnit.DAYS.between(start, end);
            // 返回结果
            return "Days between " + startDate + " and " + endDate + ": " + days + " days";
            
        } catch (DateTimeParseException e) {
            // 日期格式错误时返回错误信息
            return "Invalid date format. Please use yyyy-MM-dd format.";
        }
    }

    /**
     * 计算两个时间之间的小时差
     * @param startDateTime 开始时间，格式为 yyyy-MM-dd HH:mm:ss
     * @param endDateTime 结束时间，格式为 yyyy-MM-dd HH:mm:ss
     * @return 小时差
     */
    @Tool(description = "Calculate the number of hours between two datetime")
    public String calculateHoursBetween(
            @ToolParam(description = "Start datetime in yyyy-MM-dd HH:mm:ss format") String startDateTime,
            @ToolParam(description = "End datetime in yyyy-MM-dd HH:mm:ss format") String endDateTime) {
        
        try {
            // 创建日期时间格式化器
            DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
            // 解析开始时间字符串
            LocalDateTime start = LocalDateTime.parse(startDateTime, formatter);
            // 解析结束时间字符串
            LocalDateTime end = LocalDateTime.parse(endDateTime, formatter);
            // 计算两个时间之间的小时差
            long hours = ChronoUnit.HOURS.between(start, end);
            // 返回结果
            return "Hours between " + startDateTime + " and " + endDateTime + ": " + hours + " hours";
            
        } catch (DateTimeParseException e) {
            // 时间格式错误时返回错误信息
            return "Invalid datetime format. Please use yyyy-MM-dd HH:mm:ss format.";
        }
    }

    /**
     * 在指定日期上增加或减少天数
     * @param date 基准日期，格式为 yyyy-MM-dd
     * @param days 要增加的天数（负数表示减少）
     * @return 计算后的新日期
     */
    @Tool(description = "Add or subtract days from a given date")
    public String addDays(
            @ToolParam(description = "Base date in yyyy-MM-dd format") String date,
            @ToolParam(description = "Number of days to add (negative to subtract)") int days) {
        
        try {
            // 解析日期字符串
            LocalDate baseDate = LocalDate.parse(date);
            // 增加或减少指定天数
            LocalDate newDate = baseDate.plusDays(days);
            // 返回新日期
            return "Result: " + newDate.toString();
            
        } catch (DateTimeParseException e) {
            // 日期格式错误时返回错误信息
            return "Invalid date format. Please use yyyy-MM-dd format.";
        }
    }

    /**
     * 获取指定日期是星期几
     * @param date 日期，格式为 yyyy-MM-dd
     * @return 星期几（中文）
     */
    @Tool(description = "Get the day of week for a given date")
    public String getDayOfWeek(
            @ToolParam(description = "Date in yyyy-MM-dd format") String date) {
        
        try {
            // 解析日期字符串
            LocalDate localDate = LocalDate.parse(date);
            // 获取星期几的枚举值
            DayOfWeek dayOfWeek = localDate.getDayOfWeek();
            
            // 将英文星期转换为中文
            String chineseDayOfWeek;
            switch (dayOfWeek) {
                case MONDAY:
                    chineseDayOfWeek = "星期一";
                    break;
                case TUESDAY:
                    chineseDayOfWeek = "星期二";
                    break;
                case WEDNESDAY:
                    chineseDayOfWeek = "星期三";
                    break;
                case THURSDAY:
                    chineseDayOfWeek = "星期四";
                    break;
                case FRIDAY:
                    chineseDayOfWeek = "星期五";
                    break;
                case SATURDAY:
                    chineseDayOfWeek = "星期六";
                    break;
                case SUNDAY:
                    chineseDayOfWeek = "星期日";
                    break;
                default:
                    chineseDayOfWeek = "未知";
            }
            
            // 返回结果
            return date + " is " + chineseDayOfWeek + " (" + dayOfWeek + ")";
            
        } catch (DateTimeParseException e) {
            // 日期格式错误时返回错误信息
            return "Invalid date format. Please use yyyy-MM-dd format.";
        }
    }

    /**
     * 获取当前时间戳（毫秒）
     * @return 当前时间戳
     */
    @Tool(description = "Get current timestamp in milliseconds")
    public String getCurrentTimestamp() {
        // 获取当前时间戳（毫秒）
        long timestamp = System.currentTimeMillis();
        // 返回时间戳字符串
        return "Current timestamp: " + timestamp;
    }

    /**
     * 将时间戳转换为日期时间字符串
     * @param timestamp 时间戳（毫秒）
     * @return 格式化的日期时间字符串
     */
    @Tool(description = "Convert timestamp to datetime string")
    public String timestampToDateTime(
            @ToolParam(description = "Timestamp in milliseconds") long timestamp) {
        
        try {
            // 将时间戳转换为Instant对象
            Instant instant = Instant.ofEpochMilli(timestamp);
            // 转换为系统默认时区的LocalDateTime
            LocalDateTime dateTime = LocalDateTime.ofInstant(instant, ZoneId.systemDefault());
            // 创建格式化器
            DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
            // 格式化并返回
            return dateTime.format(formatter);
            
        } catch (Exception e) {
            // 转换失败时返回错误信息
            return "Invalid timestamp: " + e.getMessage();
        }
    }
}
```

------

## 3️⃣ 数据库操作工具

### 创建数据库操作工具类

```java
package com.zpark.zcwaiagent.tools;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.ai.tool.annotation.Tool;
import org.springframework.ai.tool.annotation.ToolParam;
import org.springframework.jdbc.core.JdbcTemplate;

import java.util.List;
import java.util.Map;
import java.util.regex.Pattern;

/**
 * 数据库操作工具类
 * 提供安全的数据库查询功能
 * 注意：为了安全，只允许执行SELECT查询
 */
public class DatabaseOperationTool {

    // Spring的JDBC模板，用于执行数据库操作
    private final JdbcTemplate jdbcTemplate;
    
    // JSON对象映射器，用于将查询结果转换为JSON字符串
    private final ObjectMapper objectMapper;
    
    // SQL注入检测的正则表达式模式
    // 检测危险的SQL关键字，如DROP、DELETE、UPDATE、INSERT等
    private static final Pattern DANGEROUS_PATTERN = Pattern.compile(
        ".*(DROP|DELETE|UPDATE|INSERT|ALTER|CREATE|TRUNCATE|EXEC|EXECUTE).*",
        Pattern.CASE_INSENSITIVE
    );

    /**
     * 构造函数，注入依赖
     * @param jdbcTemplate Spring的JDBC模板
     */
    public DatabaseOperationTool(JdbcTemplate jdbcTemplate) {
        // 将传入的JDBC模板赋值给成员变量
        this.jdbcTemplate = jdbcTemplate;
        // 创建JSON对象映射器实例
        this.objectMapper = new ObjectMapper();
    }

    /**
     * 执行数据库查询操作（只允许SELECT语句）
     * @param sql SQL查询语句
     * @return JSON格式的查询结果
     */
    @Tool(description = "Execute a SELECT query on the database and return results in JSON format")
    public String executeQuery(
            @ToolParam(description = "SQL SELECT query to execute") String sql) {
        
        try {
            // 安全检查：验证SQL语句是否安全
            if (!isSafeSql(sql)) {
                // SQL语句包含危险操作，拒绝执行
                return "Error: Only SELECT queries are allowed. Dangerous SQL detected.";
            }
            
            // 检查SQL是否以SELECT开头（忽略大小写和前导空格）
            if (!sql.trim().toUpperCase().startsWith("SELECT")) {
                // 不是SELECT语句，拒绝执行
                return "Error: Only SELECT queries are allowed.";
            }
            
            // 执行查询，返回结果列表，每行数据是一个Map
            List<Map<String, Object>> results = jdbcTemplate.queryForList(sql);
            
            // 检查查询结果是否为空
            if (results.isEmpty()) {
                // 没有查询到数据
                return "Query executed successfully. No results found.";
            }
            
            // 将查询结果转换为格式化的JSON字符串
            String jsonResult = objectMapper.writerWithDefaultPrettyPrinter()
                    .writeValueAsString(results);
            
            // 返回查询结果
            return "Query executed successfully. Results:\n" + jsonResult;
            
        } catch (Exception e) {
            // 捕获所有异常并返回错误信息
            return "Error executing query: " + e.getMessage();
        }
    }

    /**
     * 执行带参数的查询（防止SQL注入）
     * @param sql SQL查询语句，使用?作为参数占位符
     * @param params 参数值，用逗号分隔
     * @return JSON格式的查询结果
     */
    @Tool(description = "Execute a parameterized SELECT query to prevent SQL injection")
    public String executeParameterizedQuery(
            @ToolParam(description = "SQL SELECT query with ? placeholders") String sql,
            @ToolParam(description = "Parameter values separated by comma") String params) {
        
        try {
            // 安全检查：验证SQL语句是否安全
            if (!isSafeSql(sql)) {
                // SQL语句包含危险操作，拒绝执行
                return "Error: Only SELECT queries are allowed. Dangerous SQL detected.";
            }
            
            // 检查SQL是否以SELECT开头
            if (!sql.trim().toUpperCase().startsWith("SELECT")) {
                // 不是SELECT语句，拒绝执行
                return "Error: Only SELECT queries are allowed.";
            }
            
            // 将参数字符串按逗号分割成数组
            String[] paramArray = params.split(",");
            // 去除每个参数的前后空格
            Object[] trimmedParams = new Object[paramArray.length];
            for (int i = 0; i < paramArray.length; i++) {
                trimmedParams[i] = paramArray[i].trim();
            }
            
            // 执行参数化查询
            List<Map<String, Object>> results = jdbcTemplate.queryForList(sql, trimmedParams);
            
            // 检查查询结果是否为空
            if (results.isEmpty()) {
                // 没有查询到数据
                return "Query executed successfully. No results found.";
            }
            
            // 将查询结果转换为格式化的JSON字符串
            String jsonResult = objectMapper.writerWithDefaultPrettyPrinter()
                    .writeValueAsString(results);
            
            // 返回查询结果
            return "Query executed successfully. Results:\n" + jsonResult;
            
        } catch (Exception e) {
            // 捕获所有异常并返回错误信息
            return "Error executing parameterized query: " + e.getMessage();
        }
    }

    /**
     * 获取数据库中所有表的列表
     * @return 表名列表
     */
    @Tool(description = "Get list of all tables in the database")
    public String listTables() {
        try {
            // 查询PostgreSQL数据库中所有用户表
            // information_schema.tables是系统视图，包含所有表的信息
            String sql = "SELECT table_name FROM information_schema.tables " +
                        "WHERE table_schema = 'public' ORDER BY table_name";
            
            // 执行查询
            List<Map<String, Object>> results = jdbcTemplate.queryForList(sql);
            
            // 检查结果是否为空
            if (results.isEmpty()) {
                return "No tables found in the database.";
            }
            
            // 将结果转换为JSON字符串
            String jsonResult = objectMapper.writerWithDefaultPrettyPrinter()
                    .writeValueAsString(results);
            
            // 返回表列表
            return "Tables in database:\n" + jsonResult;
            
        } catch (Exception e) {
            // 捕获异常并返回错误信息
            return "Error listing tables: " + e.getMessage();
        }
    }

    /**
     * 获取指定表的结构信息
     * @param tableName 表名
     * @return 表结构信息（列名、数据类型等）
     */
    @Tool(description = "Get structure information of a specific table")
    public String describeTable(
            @ToolParam(description = "Name of the table to describe") String tableName) {
        
        try {
            // 查询表的列信息
            // information_schema.columns是系统视图，包含所有列的信息
            String sql = "SELECT column_name, data_type, is_nullable, column_default " +
                        "FROM information_schema.columns " +
                        "WHERE table_name = ? ORDER BY ordinal_position";
            
            // 执行参数化查询，防止SQL注入
            List<Map<String, Object>> results = jdbcTemplate.queryForList(sql, tableName);
            
            // 检查结果是否为空
            if (results.isEmpty()) {
                return "Table '" + tableName + "' not found or has no columns.";
            }
            
            // 将结果转换为JSON字符串
            String jsonResult = objectMapper.writerWithDefaultPrettyPrinter()
                    .writeValueAsString(results);
            
            // 返回表结构信息
            return "Structure of table '" + tableName + "':\n" + jsonResult;
            
        } catch (Exception e) {
            // 捕获异常并返回错误信息
            return "Error describing table: " + e.getMessage();
        }
    }

    /**
     * 统计表中的记录数
     * @param tableName 表名
     * @return 记录数
     */
    @Tool(description = "Count the number of records in a table")
    public String countRecords(
            @ToolParam(description = "Name of the table to count") String tableName) {
        
        try {
            // 验证表名是否安全（只允许字母、数字和下划线）
            if (!tableName.matches("^[a-zA-Z0-9_]+$")) {
                return "Error: Invalid table name.";
            }
            
            // 构建COUNT查询语句
            String sql = "SELECT COUNT(*) as total FROM " + tableName;
            
            // 执行查询，获取记录数
            Integer count = jdbcTemplate.queryForObject(sql, Integer.class);
            
            // 返回统计结果
            return "Table '" + tableName + "' has " + count + " records.";
            
        } catch (Exception e) {
            // 捕获异常并返回错误信息
            return "Error counting records: " + e.getMessage();
        }
    }

    /**
     * 检查SQL语句是否安全
     * @param sql SQL语句
     * @return true表示安全，false表示不安全
     */
    private boolean isSafeSql(String sql) {
        // 使用正则表达式检测SQL中是否包含危险关键字
        return !DANGEROUS_PATTERN.matcher(sql).matches();
    }
}
```

------

## 4️⃣ PDF生成工具优化（支持返回URL）

### 方案A：使用阿里云OSS（推荐）

#### 步骤1：添加依赖

```xml
<!-- 阿里云OSS SDK -->
<dependency>
    <groupId>com.aliyun.oss</groupId>
    <artifactId>aliyun-sdk-oss</artifactId>
    <version>3.17.4</version>
</dependency>
```

#### 步骤2：配置OSS（application.yml）

```yaml
# 阿里云OSS配置
aliyun:
  oss:
    # OSS访问端点（根据你的区域选择）
    endpoint: oss-cn-hangzhou.aliyuncs.com
    # 访问密钥ID
    access-key-id: your-access-key-id
    # 访问密钥Secret
    access-key-secret: your-access-key-secret
    # 存储桶名称
    bucket-name: your-bucket-name
    # 文件URL前缀（可选，用于自定义域名）
    url-prefix: https://your-bucket-name.oss-cn-hangzhou.aliyuncs.com/
```

好的，我继续完成剩余部分！

#### 步骤3：创建OSS配置类（续）

```java
package com.zpark.zcwaiagent.config;

import com.aliyun.oss.OSS;
import com.aliyun.oss.OSSClientBuilder;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * 阿里云OSS配置类
 * 用于创建OSS客户端Bean
 */
@Configuration
public class OssConfig {

    // 从配置文件中读取OSS端点
    @Value("${aliyun.oss.endpoint}")
    private String endpoint;

    // 从配置文件中读取访问密钥ID
    @Value("${aliyun.oss.access-key-id}")
    private String accessKeyId;

    // 从配置文件中读取访问密钥Secret
    @Value("${aliyun.oss.access-key-secret}")
    private String accessKeySecret;

    /**
     * 创建OSS客户端Bean
     * @return OSS客户端实例
     */
    @Bean
    public OSS ossClient() {
        // 使用OSSClientBuilder创建OSS客户端
        // 参数：端点、访问密钥ID、访问密钥Secret
        return new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);
    }
}
```

#### 步骤4：创建增强版PDF生成工具

```java
package com.zpark.zcwaiagent.tools;

import cn.hutool.core.io.FileUtil;
import com.aliyun.oss.OSS;
import com.aliyun.oss.model.PutObjectRequest;
import com.itextpdf.kernel.font.PdfFont;
import com.itextpdf.kernel.font.PdfFontFactory;
import com.itextpdf.kernel.pdf.PdfDocument;
import com.itextpdf.kernel.pdf.PdfWriter;
import com.itextpdf.layout.Document;
import com.itextpdf.layout.element.Paragraph;
import com.zpark.zcwaiagent.constant.FileConstant;
import org.springframework.ai.tool.annotation.Tool;
import org.springframework.ai.tool.annotation.ToolParam;
import org.springframework.beans.factory.annotation.Value;

import java.io.File;
import java.io.IOException;
import java.util.UUID;

/**
 * 增强版PDF生成工具
 * 支持生成PDF并上传到阿里云OSS，返回可访问的URL
 */
public class EnhancedPDFGenerationTool {

    // 注入OSS客户端
    private final OSS ossClient;

    // 从配置文件中读取OSS存储桶名称
    @Value("${aliyun.oss.bucket-name}")
    private String bucketName;

    // 从配置文件中读取URL前缀
    @Value("${aliyun.oss.url-prefix}")
    private String urlPrefix;

    /**
     * 构造函数，注入OSS客户端
     * @param ossClient 阿里云OSS客户端
     */
    public EnhancedPDFGenerationTool(OSS ossClient) {
        // 将传入的OSS客户端赋值给成员变量
        this.ossClient = ossClient;
    }

    /**
     * 生成PDF并上传到OSS，返回可访问的URL
     * @param fileName PDF文件名（不含路径）
     * @param content PDF内容
     * @return 包含可访问URL的结果信息
     */
    @Tool(description = "Generate a PDF file, upload to cloud storage, and return accessible URL")
    public String generatePDFWithURL(
            @ToolParam(description = "Name of the PDF file") String fileName,
            @ToolParam(description = "Content to be included in the PDF") String content) {

        // 临时文件目录
        String tempDir = FileConstant.FILE_SAVE_DIR + "/temp";
        // 临时文件完整路径
        String tempFilePath = tempDir + "/" + fileName;

        try {
            // 步骤1：生成PDF到临时目录
            // 创建临时目录
            FileUtil.mkdir(tempDir);

            // 创建PdfWriter和PdfDocument对象
            try (PdfWriter writer = new PdfWriter(tempFilePath);
                 PdfDocument pdf = new PdfDocument(writer);
                 Document document = new Document(pdf)) {

                // 使用内置中文字体
                PdfFont font = PdfFontFactory.createFont("STSongStd-Light", "UniGB-UCS2-H");
                // 设置文档字体
                document.setFont(font);
                // 创建段落并添加内容
                Paragraph paragraph = new Paragraph(content);
                // 将段落添加到文档
                document.add(paragraph);
            }

            // 步骤2：上传到OSS
            // 在OSS中的对象键（文件路径），使用pdf目录存储
            String objectKey = "pdf/" + fileName;
            // 创建文件对象
            File file = new File(tempFilePath);
            // 创建上传请求对象
            PutObjectRequest putObjectRequest = new PutObjectRequest(bucketName, objectKey, file);
            // 执行上传操作
            ossClient.putObject(putObjectRequest);

            // 步骤3：生成可访问的URL
            // 拼接完整的文件访问URL
            String fileUrl = urlPrefix + objectKey;

            // 步骤4：删除本地临时文件
            // 删除临时文件以释放磁盘空间
            FileUtil.del(tempFilePath);

            // 步骤5：返回成功信息和URL
            return "PDF generated and uploaded successfully.\nAccess URL: " + fileUrl;

        } catch (IOException e) {
            // 捕获IO异常并返回错误信息
            return "Error generating or uploading PDF: " + e.getMessage();
        } finally {
            // 确保临时文件被清理（即使发生异常）
            try {
                // 尝试删除临时文件
                FileUtil.del(tempFilePath);
            } catch (Exception ignored) {
                // 忽略删除失败的异常
            }
        }
    }

    /**
     * 生成PDF并上传到OSS，使用随机文件名
     * @param content PDF内容
     * @return 包含可访问URL的结果信息
     */
    @Tool(description = "Generate a PDF with random filename, upload to cloud storage, and return URL")
    public String generatePDFWithRandomName(
            @ToolParam(description = "Content to be included in the PDF") String content) {

        // 生成随机文件名，使用UUID确保唯一性
        String randomFileName = "pdf_" + UUID.randomUUID().toString() + ".pdf";
        // 调用主方法生成PDF
        return generatePDFWithURL(randomFileName, content);
    }

    /**
     * 删除OSS上的PDF文件
     * @param fileName 要删除的文件名
     * @return 删除结果信息
     */
    @Tool(description = "Delete a PDF file from cloud storage")
    public String deletePDFFromOSS(
            @ToolParam(description = "Name of the PDF file to delete") String fileName) {

        try {
            // 构建OSS中的对象键
            String objectKey = "pdf/" + fileName;
            // 执行删除操作
            ossClient.deleteObject(bucketName, objectKey);
            // 返回成功信息
            return "PDF file deleted successfully: " + fileName;

        } catch (Exception e) {
            // 捕获异常并返回错误信息
            return "Error deleting PDF: " + e.getMessage();
        }
    }
}
```

### 方案B：本地文件 + Web服务器（简单方案）

```java
package com.zpark.zcwaiagent.tools;

import cn.hutool.core.io.FileUtil;
import com.itextpdf.kernel.font.PdfFont;
import com.itextpdf.kernel.font.PdfFontFactory;
import com.itextpdf.kernel.pdf.PdfDocument;
import com.itextpdf.kernel.pdf.PdfWriter;
import com.itextpdf.layout.Document;
import com.itextpdf.layout.element.Paragraph;
import org.springframework.ai.tool.annotation.Tool;
import org.springframework.ai.tool.annotation.ToolParam;
import org.springframework.beans.factory.annotation.Value;

import java.io.IOException;

/**
 * 简化版PDF生成工具
 * 生成PDF到静态资源目录，通过Web服务器提供访问
 */
public class SimplePDFGenerationTool {

    // 从配置文件中读取服务器地址
    @Value("${server.port}")
    private int serverPort;

    // 从配置文件中读取上下文路径
    @Value("${server.servlet.context-path}")
    private String contextPath;

    /**
     * 生成PDF到静态资源目录，返回可访问的URL
     * @param fileName PDF文件名
     * @param content PDF内容
     * @return 包含可访问URL的结果信息
     */
    @Tool(description = "Generate a PDF file and return accessible URL via web server")
    public String generatePDFWithURL(
            @ToolParam(description = "Name of the PDF file") String fileName,
            @ToolParam(description = "Content to be included in the PDF") String content) {

        // 静态资源目录路径（Spring Boot会自动提供访问）
        String fileDir = "src/main/resources/static/pdf";
        // 完整文件路径
        String filePath = fileDir + "/" + fileName;

        try {
            // 创建目录（如果不存在）
            FileUtil.mkdir(fileDir);

            // 创建PdfWriter和PdfDocument对象
            try (PdfWriter writer = new PdfWriter(filePath);
                 PdfDocument pdf = new PdfDocument(writer);
                 Document document = new Document(pdf)) {

                // 使用内置中文字体
                PdfFont font = PdfFontFactory.createFont("STSongStd-Light", "UniGB-UCS2-H");
                // 设置文档字体
                document.setFont(font);
                // 创建段落并添加内容
                Paragraph paragraph = new Paragraph(content);
                // 将段落添加到文档
                document.add(paragraph);
            }

            // 构建可访问的URL
            // 格式：http://localhost:8123/api/pdf/文件名.pdf
            String fileUrl = "http://localhost:" + serverPort + contextPath + "/pdf/" + fileName;

            // 返回成功信息和URL
            return "PDF generated successfully.\nAccess URL: " + fileUrl +
                   "\nLocal path: " + filePath;

        } catch (IOException e) {
            // 捕获IO异常并返回错误信息
            return "Error generating PDF: " + e.getMessage();
        }
    }
}
```

------

## 5️⃣ 工具执行日志和控制

### 步骤1：创建数据库表

```sql
-- 创建工具调用日志表
CREATE TABLE tool_call_logs (
    -- 主键ID，自动递增
    id SERIAL PRIMARY KEY,
    -- 工具名称
    tool_name VARCHAR(100) NOT NULL,
    -- 工具参数（JSON格式）
    parameters TEXT,
    -- 执行结果
    result TEXT,
    -- 执行时间（毫秒）
    execution_time BIGINT,
    -- 执行状态：success, error
    status VARCHAR(20) NOT NULL,
    -- 错误信息（如果有）
    error_message TEXT,
    -- 创建时间
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    -- 用户ID（可选，用于多用户场景）
    user_id VARCHAR(50),
    -- 会话ID（可选，用于追踪对话）
    session_id VARCHAR(100)
);

-- 创建索引以提高查询性能
CREATE INDEX idx_tool_name ON tool_call_logs(tool_name);
CREATE INDEX idx_created_at ON tool_call_logs(created_at);
CREATE INDEX idx_status ON tool_call_logs(status);
```

### 步骤2：创建日志实体类

```java
package com.zpark.zcwaiagent.entity;

import lombok.Data;
import java.time.LocalDateTime;

/**
 * 工具调用日志实体类
 * 对应数据库表 tool_call_logs
 */
@Data
public class ToolCallLog {
    
    // 主键ID
    private Long id;
    
    // 工具名称
    private String toolName;
    
    // 工具参数（JSON格式）
    private String parameters;
    
    // 执行结果
    private String result;
    
    // 执行时间（毫秒）
    private Long executionTime;
    
    // 执行状态
    private String status;
    
    // 错误信息
    private String errorMessage;
    
    // 创建时间
    private LocalDateTime createdAt;
    
    // 用户ID
    private String userId;
    
    // 会话ID
    private String sessionId;
}
```

### 步骤3：添加AOP依赖

```xml
<!-- Spring AOP依赖 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>
```

### 步骤4：创建工具调用日志切面

```java
package com.zpark.zcwaiagent.aspect;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.reflect.MethodSignature;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.ai.tool.annotation.Tool;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;

import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.Map;

/**
 * 工具调用日志切面
 * 使用AOP拦截所有@Tool注解的方法，记录执行日志
 */
@Aspect
@Component
public class ToolCallAspect {

    // 日志记录器
    private static final Logger log = LoggerFactory.getLogger(ToolCallAspect.class);

    // 注入JDBC模板，用于保存日志到数据库
    @Autowired
    private JdbcTemplate jdbcTemplate;

    // JSON对象映射器，用于序列化参数
    private final ObjectMapper objectMapper = new ObjectMapper();

    /**
     * 环绕通知：拦截所有@Tool注解的方法
     * @param joinPoint 连接点，包含方法信息
     * @return 方法执行结果
     * @throws Throwable 方法执行可能抛出的异常
     */
    @Around("@annotation(org.springframework.ai.tool.annotation.Tool)")
    public Object logToolExecution(ProceedingJoinPoint joinPoint) throws Throwable {
        
        // 记录开始时间（纳秒）
        long startTime = System.nanoTime();
        
        // 获取方法签名
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        // 获取方法对象
        Method method = signature.getMethod();
        // 获取@Tool注解
        Tool toolAnnotation = method.getAnnotation(Tool.class);
        
        // 获取工具名称（方法名）
        String toolName = method.getName();
        // 获取方法参数值
        Object[] args = joinPoint.getArgs();
        // 获取参数名称
        String[] paramNames = signature.getParameterNames();
        
        // 构建参数Map
        Map<String, Object> paramMap = new HashMap<>();
        for (int i = 0; i < paramNames.length; i++) {
            // 将参数名和参数值放入Map
            paramMap.put(paramNames[i], args[i]);
        }
        
        // 将参数Map转换为JSON字符串
        String parametersJson = objectMapper.writeValueAsString(paramMap);
        
        // 记录工具调用开始
        log.info("工具调用开始 - 工具名: {}, 参数: {}", toolName, parametersJson);
        
        // 执行结果
        Object result = null;
        // 执行状态
        String status = "success";
        // 错误信息
        String errorMessage = null;
        
        try {
            // 执行目标方法
            result = joinPoint.proceed();
            
            // 记录工具调用成功
            log.info("工具调用成功 - 工具名: {}, 结果: {}", toolName, result);
            
        } catch (Throwable e) {
            // 捕获异常
            status = "error";
            errorMessage = e.getMessage();
            
            // 记录工具调用失败
            log.error("工具调用失败 - 工具名: {}, 错误: {}", toolName, errorMessage, e);
            
            // 重新抛出异常
            throw e;
            
        } finally {
            // 计算执行时间（毫秒）
            long endTime = System.nanoTime();
            long executionTime = (endTime - startTime) / 1_000_000;
            
            // 记录执行时间
            log.info("工具调用结束 - 工具名: {}, 执行时间: {}ms", toolName, executionTime);
            
            // 保存日志到数据库
            saveLogToDatabase(toolName, parametersJson, 
                            result != null ? result.toString() : null,
                            executionTime, status, errorMessage);
        }
        
        // 返回执行结果
        return result;
    }

    /**
     * 保存日志到数据库
     * @param toolName 工具名称
     * @param parameters 参数JSON
     * @param result 执行结果
     * @param executionTime 执行时间
     * @param status 执行状态
     * @param errorMessage 错误信息
     */
    private void saveLogToDatabase(String toolName, String parameters, String result,
                                   long executionTime, String status, String errorMessage) {
        try {
            // SQL插入语句
            String sql = "INSERT INTO tool_call_logs " +
                        "(tool_name, parameters, result, execution_time, status, error_message) " +
                        "VALUES (?, ?, ?, ?, ?, ?)";
            
            // 执行插入操作
            jdbcTemplate.update(sql, toolName, parameters, result, 
                              executionTime, status, errorMessage);
            
        } catch (Exception e) {
            // 记录保存日志失败的错误（不影响主流程）
            log.error("保存工具调用日志失败: {}", e.getMessage(), e);
        }
    }
}
```

### 步骤5：创建工具执行管理器

```java
package com.zpark.zcwaiagent.manager;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Map;

/**
 * 工具执行管理器
 * 提供工具调用的查询和统计功能
 */
@Component
public class ToolExecutionManager {

    // 日志记录器
    private static final Logger log = LoggerFactory.getLogger(ToolExecutionManager.class);

    // 注入JDBC模板
    @Autowired
    private JdbcTemplate jdbcTemplate;

    /**
     * 查询最近的工具调用记录
     * @param limit 返回记录数量
     * @return 工具调用记录列表
     */
    public List<Map<String, Object>> getRecentToolCalls(int limit) {
        // SQL查询语句，按创建时间倒序
        String sql = "SELECT * FROM tool_call_logs " +
                    "ORDER BY created_at DESC LIMIT ?";
        
        // 执行查询并返回结果
        return jdbcTemplate.queryForList(sql, limit);
    }

    /**
     * 查询指定工具的调用记录
     * @param toolName 工具名称
     * @param limit 返回记录数量
     * @return 工具调用记录列表
     */
    public List<Map<String, Object>> getToolCallsByName(String toolName, int limit) {
        // SQL查询语句
        String sql = "SELECT * FROM tool_call_logs " +
                    "WHERE tool_name = ? " +
                    "ORDER BY created_at DESC LIMIT ?";
        
        // 执行查询并返回结果
        return jdbcTemplate.queryForList(sql, toolName, limit);
    }

    /**
     * 统计工具调用次数
     * @return 每个工具的调用次数
     */
    public List<Map<String, Object>> getToolCallStatistics() {
        // SQL统计查询
        String sql = "SELECT tool_name, " +
                    "COUNT(*) as total_calls, " +
                    "SUM(CASE WHEN status = 'success' THEN 1 ELSE 0 END) as success_count, " +
                    "SUM(CASE WHEN status = 'error' THEN 1 ELSE 0 END) as error_count, " +
                    "AVG(execution_time) as avg_execution_time " +
                    "FROM tool_call_logs " +
                    "GROUP BY tool_name " +
                    "ORDER BY total_calls DESC";
        
        // 执行查询并返回结果
        return jdbcTemplate.queryForList(sql);
    }

    /**
     * 获取工具调用的平均执行时间
     * @param toolName 工具名称
     * @return 平均执行时间（毫秒）
     */
    public Double getAverageExecutionTime(String toolName) {
        // SQL查询语句
        String sql = "SELECT AVG(execution_time) FROM tool_call_logs " +
                    "WHERE tool_name = ?";
        
        // 执行查询并返回结果
        return jdbcTemplate.queryForObject(sql, Double.class, toolName);
    }

    /**
     * 清理旧的日志记录
     * @param daysToKeep 保留最近多少天的记录
     * @return 删除的记录数
     */
    public int cleanOldLogs(int daysToKeep) {
        // SQL删除语句
        String sql = "DELETE FROM tool_call_logs " +
                    "WHERE created_at < NOW() - INTERVAL '" + daysToKeep + " days'";
        
        // 执行删除操作
        int deletedCount = jdbcTemplate.update(sql);
        
        // 记录日志
        log.info("清理了 {} 条旧的工具调用日志", deletedCount);
        
        // 返回删除数量
        return deletedCount;
    }
}
```

------

## 6️⃣ PDF解析工具

### 步骤1：添加依赖

```xml
<!-- Apache PDFBox用于解析PDF -->
<dependency>
    <groupId>org.apache.pdfbox</groupId>
    <artifactId>pdfbox</artifactId>
    <version>3.0.1</version>
</dependency>
```

### 步骤2：创建PDF解析工具类

```java
package com.zpark.zcwaiagent.tools;

import org.apache.pdfbox.pdmodel.PDDocument;
import org.apache.pdfbox.text.PDFTextStripper;
import org.springframework.ai.tool.annotation.Tool;
import org.springframework.ai.tool.annotation.ToolParam;
import org.springframework.ai.vectorstore.VectorStore;
import org.springframework.ai.document.Document;

import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/**
 * PDF文件解析工具
 * 提供PDF文本提取和向量化存储功能
 */
public class PDFParsingTool {

    // 向量存储，用于存储解析后的PDF内容
    private final VectorStore vectorStore;

    /**
     * 构造函数，注入向量存储
     * @param vectorStore 向量存储实例
     */
    public PDFParsingTool(VectorStore vectorStore) {
        // 将传入的向量存储赋值给成员变量
        this.vectorStore = vectorStore;
    }

    /**
     * 解析PDF文件，提取文本内容
     * @param pdfPath PDF文件路径（本地路径或URL）
     * @return 提取的文本内容
     */
    @Tool(description = "Parse a PDF file and extract text content")
    public String parsePDF(
            @ToolParam(description = "Path or URL to the PDF file") String pdfPath) {
        
        // PDF文档对象
        PDDocument document = null;
        
        try {
            // 判断是URL还是本地文件路径
            if (pdfPath.startsWith("http://") || pdfPath.startsWith("https://")) {
                // 从URL加载PDF
                URL url = new URL(pdfPath);
                document = PDDocument.load(url.openStream());
            } else {
                // 从本地文件加载PDF
                File file = new File(pdfPath);
                // 检查文件是否存在
                if (!file.exists()) {
                    return "Error: PDF file not found at path: " + pdfPath;
                }
                document = PDDocument.load(file);
            }
            
            // 创建PDF文本提取器
            PDFTextStripper stripper = new PDFTextStripper();
            // 提取所有页面的文本
            String text = stripper.getText(document);
            
            // 获取PDF页数
            int pageCount = document.getNumberOfPages();
            
            // 返回提取结果
            return "PDF parsed successfully.\n" +
                   "Total pages: " + pageCount + "\n" +
                   "Extracted text:\n" + text;
            
        } catch (IOException e) {
            // 捕获IO异常并返回错误信息
            return "Error parsing PDF: " + e.getMessage();
            
        } finally {
            // 关闭PDF文档，释放资源
            if (document != null) {
                try {
                    document.close();
                } catch (IOException e) {
                    // 忽略关闭异常
                }
            }
        }
    }

    /**
     * 解析PDF指定页面的内容
     * @param pdfPath PDF文件路径
     * @param startPage 起始页码（从1开始）
     * @param endPage 结束页码
     * @return 提取的文本内容
     */
    @Tool(description = "Parse specific pages of a PDF file")
    public String parsePDFPages(
            @ToolParam(description = "Path to the PDF file") String pdfPath,
            @ToolParam(description = "Start page number (1-based)") int startPage,
            @ToolParam(description = "End page number") int endPage) {
        
        // PDF文档对象
        PDDocument document = null;
        
        try {
            // 加载PDF文件
            File file = new File(pdfPath);
            if (!file.exists()) {
                return "Error: PDF file not found at path: " + pdfPath;
            }
            document = PDDocument.load(file);
            
            // 验证页码范围
            int totalPages = document.getNumberOfPages();
            if (startPage < 1 || endPage > totalPages || startPage > endPage) {
                return "Error: Invalid page range. PDF has " + totalPages + " pages.";
            }
            
            // 创建PDF文本提取器
            PDFTextStripper stripper = new PDFTextStripper();
            // 设置起始页
            stripper.setStartPage(startPage);
            // 设置结束页
            stripper.setEndPage(endPage);
            // 提取指定页面的文本
            String text = stripper.getText(document);
            
            // 返回提取结果
            return "PDF pages " + startPage + "-" + endPage + " parsed successfully.\n" +
                   "Extracted text:\n" + text;
            
        } catch (IOException e) {
            // 捕获IO异常并返回错误信息
            return "Error parsing PDF pages: " + e.getMessage();
            
        } finally {
            // 关闭PDF文档
            if (document != null) {
                try {
                    document.close();
                } catch (IOException e) {
                    // 忽略关闭异常
                }
            }
        }
    }

    /**
     * 解析PDF并存储到向量数据库
     * @param pdfPath PDF文件路径
     * @param chunkSize 文本分块大小（字符数）
     * @return 存储结果信息
     */
    @Tool(description = "Parse PDF and store content in vector database for RAG")
    public String parsePDFToVectorStore(
            @ToolParam(description = "Path to the PDF file") String pdfPath,
            @ToolParam(description = "Chunk size for text splitting (characters)") int chunkSize) {
        
        // PDF文档对象
        PDDocument document = null;
        
        try {
                       // 加载PDF文件
            File file = new File(pdfPath);
            if (!file.exists()) {
                return "Error: PDF file not found at path: " + pdfPath;
            }
            document = PDDocument.load(file);
            
            // 创建PDF文本提取器
            PDFTextStripper stripper = new PDFTextStripper();
            // 提取所有文本
            String fullText = stripper.getText(document);
            
            // 步骤1：将文本分块
            List<String> chunks = splitTextIntoChunks(fullText, chunkSize);
            
            // 步骤2：创建Document对象列表
            List<Document> documents = new ArrayList<>();
            for (int i = 0; i < chunks.size(); i++) {
                // 为每个文本块创建Document对象
                // 添加元数据：来源文件、块索引
                Map<String, Object> metadata = Map.of(
                    "source", pdfPath,
                    "chunk_index", i,
                    "total_chunks", chunks.size(),
                    "page_count", document.getNumberOfPages()
                );
                // 创建Document并添加到列表
                documents.add(new Document(chunks.get(i), metadata));
            }
            
            // 步骤3：存储到向量数据库
            vectorStore.add(documents);
            
            // 返回成功信息
            return "PDF parsed and stored successfully.\n" +
                   "Total pages: " + document.getNumberOfPages() + "\n" +
                   "Text chunks created: " + chunks.size() + "\n" +
                   "Stored in vector database for RAG retrieval.";
            
        } catch (IOException e) {
            // 捕获IO异常并返回错误信息
            return "Error parsing PDF to vector store: " + e.getMessage();
            
        } finally {
            // 关闭PDF文档
            if (document != null) {
                try {
                    document.close();
                } catch (IOException e) {
                    // 忽略关闭异常
                }
            }
        }
    }

    /**
     * 获取PDF文件的基本信息
     * @param pdfPath PDF文件路径
     * @return PDF文件信息
     */
    @Tool(description = "Get basic information about a PDF file")
    public String getPDFInfo(
            @ToolParam(description = "Path to the PDF file") String pdfPath) {
        
        // PDF文档对象
        PDDocument document = null;
        
        try {
            // 加载PDF文件
            File file = new File(pdfPath);
            if (!file.exists()) {
                return "Error: PDF file not found at path: " + pdfPath;
            }
            document = PDDocument.load(file);
            
            // 获取PDF信息
            int pageCount = document.getNumberOfPages();
            // 获取文档信息字典
            var info = document.getDocumentInformation();
            
            // 构建信息字符串
            StringBuilder infoBuilder = new StringBuilder();
            infoBuilder.append("PDF File Information:\n");
            infoBuilder.append("File path: ").append(pdfPath).append("\n");
            infoBuilder.append("Total pages: ").append(pageCount).append("\n");
            
            // 添加文档元数据（如果存在）
            if (info.getTitle() != null) {
                infoBuilder.append("Title: ").append(info.getTitle()).append("\n");
            }
            if (info.getAuthor() != null) {
                infoBuilder.append("Author: ").append(info.getAuthor()).append("\n");
            }
            if (info.getSubject() != null) {
                infoBuilder.append("Subject: ").append(info.getSubject()).append("\n");
            }
            if (info.getCreationDate() != null) {
                infoBuilder.append("Creation date: ").append(info.getCreationDate()).append("\n");
            }
            
            // 返回信息
            return infoBuilder.toString();
            
        } catch (IOException e) {
            // 捕获IO异常并返回错误信息
            return "Error getting PDF info: " + e.getMessage();
            
        } finally {
            // 关闭PDF文档
            if (document != null) {
                try {
                    document.close();
                } catch (IOException e) {
                    // 忽略关闭异常
                }
            }
        }
    }

    /**
     * 将长文本分割成固定大小的块
     * @param text 原始文本
     * @param chunkSize 每块的字符数
     * @return 文本块列表
     */
    private List<String> splitTextIntoChunks(String text, int chunkSize) {
        // 创建结果列表
        List<String> chunks = new ArrayList<>();
        
        // 如果文本为空，直接返回空列表
        if (text == null || text.isEmpty()) {
            return chunks;
        }
        
        // 计算需要分割成多少块
        int length = text.length();
        // 从0开始，每次移动chunkSize个字符
        for (int i = 0; i < length; i += chunkSize) {
            // 计算当前块的结束位置
            int end = Math.min(i + chunkSize, length);
            // 提取子字符串并添加到列表
            chunks.add(text.substring(i, end));
        }
        
        // 返回分块结果
        return chunks;
    }

    /**
     * 智能分割文本（按段落和句子）
     * @param text 原始文本
     * @param maxChunkSize 最大块大小
     * @return 文本块列表
     */
    private List<String> smartSplitText(String text, int maxChunkSize) {
        // 创建结果列表
        List<String> chunks = new ArrayList<>();
        
        // 按段落分割（双换行符）
        String[] paragraphs = text.split("\n\n");
        
        // 当前块的内容
        StringBuilder currentChunk = new StringBuilder();
        
        // 遍历每个段落
        for (String paragraph : paragraphs) {
            // 如果当前块加上新段落不超过最大大小
            if (currentChunk.length() + paragraph.length() <= maxChunkSize) {
                // 添加到当前块
                if (currentChunk.length() > 0) {
                    currentChunk.append("\n\n");
                }
                currentChunk.append(paragraph);
            } else {
                // 当前块已满，保存并开始新块
                if (currentChunk.length() > 0) {
                    chunks.add(currentChunk.toString());
                    currentChunk = new StringBuilder();
                }
                
                // 如果单个段落就超过最大大小，需要进一步分割
                if (paragraph.length() > maxChunkSize) {
                    // 按句子分割
                    String[] sentences = paragraph.split("\\. ");
                    for (String sentence : sentences) {
                        if (currentChunk.length() + sentence.length() <= maxChunkSize) {
                            if (currentChunk.length() > 0) {
                                currentChunk.append(". ");
                            }
                            currentChunk.append(sentence);
                        } else {
                            if (currentChunk.length() > 0) {
                                chunks.add(currentChunk.toString());
                                currentChunk = new StringBuilder();
                            }
                            currentChunk.append(sentence);
                        }
                    }
                } else {
                    // 段落大小合适，直接添加
                    currentChunk.append(paragraph);
                }
            }
        }
        
        // 添加最后一个块
        if (currentChunk.length() > 0) {
            chunks.add(currentChunk.toString());
        }
        
        // 返回分块结果
        return chunks;
    }
}
                  
```

------

## 7️⃣ 更新工具注册类

现在需要将所有新工具注册到系统中：

```java
package com.zpark.zcwaiagent.tools;

import com.aliyun.oss.OSS;
import org.springframework.ai.tool.ToolCallback;
import org.springframework.ai.tool.ToolCallbacks;
import org.springframework.ai.vectorstore.VectorStore;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.mail.javamail.JavaMailSender;

/**
 * 工具注册配置类
 * 注册所有AI工具到Spring容器
 */
@Configuration
public class ToolRegistration {

    // 从配置文件中注入搜索API密钥
    @Value("${search-api.api-key}")
    private String searchApiKey;

    // 注入邮件发送器（如果配置了邮件功能）
    @Autowired(required = false)
    private JavaMailSender mailSender;

    // 注入JDBC模板（用于数据库操作工具）
    @Autowired
    private JdbcTemplate jdbcTemplate;

    // 注入OSS客户端（如果配置了OSS功能）
    @Autowired(required = false)
    private OSS ossClient;

    // 注入向量存储（用于PDF解析工具）
    @Autowired
    private VectorStore vectorStore;

    /**
     * 注册所有工具的Bean
     * @return 工具回调数组
     */
    @Bean
    public ToolCallback[] allTools() {
        // 创建文件操作工具实例
        FileOperationTool fileOperationTool = new FileOperationTool();
        
        // 创建网络搜索工具实例
        WebSearchTool webSearchTool = new WebSearchTool(searchApiKey);
        
        // 创建网页抓取工具实例
        WebScrapingTool webScrapingTool = new WebScrapingTool();
        
        // 创建资源下载工具实例
        ResourceDownloadTool resourceDownloadTool = new ResourceDownloadTool();
        
        // 创建终端操作工具实例
        TerminalOperationTool terminalOperationTool = new TerminalOperationTool();
        
        // 创建PDF生成工具实例
        PDFGenerationTool pdfGenerationTool = new PDFGenerationTool();
        
        // 创建时间工具实例（新增）
        DateTimeTool dateTimeTool = new DateTimeTool();
        
        // 创建数据库操作工具实例（新增）
        DatabaseOperationTool databaseOperationTool = new DatabaseOperationTool(jdbcTemplate);
        
        // 创建PDF解析工具实例（新增）
        PDFParsingTool pdfParsingTool = new PDFParsingTool(vectorStore);
        
        // 如果配置了邮件发送器，创建邮件工具实例
        if (mailSender != null) {
            EmailSendingTool emailSendingTool = new EmailSendingTool(mailSender);
            
            // 如果配置了OSS，创建增强版PDF工具
            if (ossClient != null) {
                EnhancedPDFGenerationTool enhancedPDFTool = new EnhancedPDFGenerationTool(ossClient);
                
                // 返回包含所有工具的数组（包含邮件和OSS）
                return ToolCallbacks.from(
                    fileOperationTool,          // 文件操作工具
                    webSearchTool,              // 网络搜索工具
                    webScrapingTool,            // 网页抓取工具
                    resourceDownloadTool,       // 资源下载工具
                    terminalOperationTool,      // 终端操作工具
                    pdfGenerationTool,          // 基础PDF生成工具
                    enhancedPDFTool,            // 增强版PDF工具（OSS）
                    dateTimeTool,               // 时间工具
                    databaseOperationTool,      // 数据库操作工具
                    pdfParsingTool,             // PDF解析工具
                    emailSendingTool            // 邮件发送工具
                );
            } else {
                // 返回包含所有工具的数组（包含邮件，不含OSS）
                return ToolCallbacks.from(
                    fileOperationTool,          // 文件操作工具
                    webSearchTool,              // 网络搜索工具
                    webScrapingTool,            // 网页抓取工具
                    resourceDownloadTool,       // 资源下载工具
                    terminalOperationTool,      // 终端操作工具
                    pdfGenerationTool,          // PDF生成工具
                    dateTimeTool,               // 时间工具
                    databaseOperationTool,      // 数据库操作工具
                    pdfParsingTool,             // PDF解析工具
                    emailSendingTool            // 邮件发送工具
                );
            }
        } else {
            // 返回基础工具数组（不含邮件功能）
            return ToolCallbacks.from(
                fileOperationTool,          // 文件操作工具
                webSearchTool,              // 网络搜索工具
                webScrapingTool,            // 网页抓取工具
                resourceDownloadTool,       // 资源下载工具
                terminalOperationTool,      // 终端操作工具
                pdfGenerationTool,          // PDF生成工具
                dateTimeTool,               // 时间工具
                databaseOperationTool,      // 数据库操作工具
                pdfParsingTool              // PDF解析工具
            );
        }
    }
}
```

------

## 8️⃣ 完整的配置文件示例

### application.yml 完整配置

```yaml
spring:
  # 数据源配置
  datasource:
    url: jdbc:postgresql://rm-cn-fsw4nudnq0004oto.rwlb.rds.aliyuncs.com:5432/zcw_ai_agent
    username: my_user
    password: 1108628zcwQ@
  
  # 应用名称
  application:
    name: zcw-ai-agent
  
  # Spring AI配置
  ai:
    # 向量存储配置
    vectorstore:
      pgvector:
        index-type: hnsw
        dimension: 1536
        distance-type: cosine_distance
        max-document-batch-size: 1000
    # 通义千问配置
    dashscope:
      api-key: sk-2f8391bf082841549f51f075ff9d53f5
      chat:
        options:
          model: qwen-plus
  
  # 邮件配置（新增）
  mail:
    host: smtp.qq.com
    port: 587
    username: your-email@qq.com
    password: your-authorization-code
    protocol: smtp
    default-encoding: UTF-8
    properties:
      mail:
        smtp:
          auth: true
          starttls:
            enable: true
            required: true
          connectiontimeout: 5000
          timeout: 5000
          writetimeout: 5000

# 服务器配置
server:
  port: 8123
  servlet:
    context-path: /api

# Swagger文档配置
springdoc:
  swagger-ui:
    path: /swagger-ui.html
    tags-sorter: alpha
    operations-sorter: alpha
  api-docs:
    path: /v3/api-docs
  group-configs:
    - group: 'default'
      paths-to-match: '/**'
      packages-to-scan: com.zpark.zcwaiagent.controller

# Knife4j配置
knife4j:
  enable: true
  setting:
    language: zh_cn

# 搜索API配置
search-api:
  api-key: of5M9jMNF9Kc5QW6NJG49C3g

# 阿里云OSS配置（新增）
aliyun:
  oss:
    endpoint: oss-cn-hangzhou.aliyuncs.com
    access-key-id: your-access-key-id
    access-key-secret: your-access-key-secret
    bucket-name: your-bucket-name
    url-prefix: https://your-bucket-name.oss-cn-hangzhou.aliyuncs.com/
```

------

## 9️⃣ 完整的 pom.xml 依赖

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.3.5</version>
        <relativePath/>
    </parent>
    
    <groupId>com.zpark</groupId>
    <artifactId>zcw-ai-agent</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>zcw-ai-agent</name>
    <description>zcw-ai-agent</description>
    
    <properties>
        <java.version>17</java.version>
    </properties>
    
    <repositories>
        <repository>
            <id>spring-milestones</id>
            <name>Spring Milestones</name>
            <url>https://repo.spring.io/milestone</url>
            <snapshots>
                <enabled>false</enabled>
            </snapshots>
        </repository>
    </repositories>

    <dependencies>
        <!-- Spring Boot Web -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        
        <!-- Spring Boot Mail（新增） -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-mail</artifactId>
        </dependency>
        
        <!-- Spring Boot AOP（新增） -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-aop</artifactId>
        </dependency>
        
        <!-- PDF文件处理库 -->
        <dependency>
            <groupId>com.itextpdf</groupId>
            <artifactId>itext-core</artifactId>
            <version>9.1.0</version>
            <type>pom</type>
        </dependency>
        
        <!-- PDF中文字体支持 -->
        <dependency>
            <groupId>com.itextpdf</groupId>
            <artifactId>font-asian</artifactId>
            <version>9.1.0</version>
        </dependency>
        
        <!-- Apache PDFBox（新增，用于PDF解析） -->
        <dependency>
            <groupId>org.apache.pdfbox</groupId>
            <artifactId>pdfbox</artifactId>
            <version>3.0.1</version>
        </dependency>
        
        <!-- 阿里云OSS SDK（新增） -->
        <dependency>
            <groupId>com.aliyun.oss</groupId>
            <artifactId>aliyun-sdk-oss</artifactId>
            <version>3.17.4</version>
        </dependency>

        <!-- 网页内容抓取和解析库 -->
        <dependency>
            <groupId>org.jsoup</groupId>
            <artifactId>jsoup</artifactId>
            <version>1.19.1</version>
        </dependency>
        
        <!-- Hutool工具类 -->
        <dependency>
            <groupId>cn.hutool</groupId>
            <artifactId>hutool-all</artifactId>
            <version>5.8.22</version>
        </dependency>
        
        <!-- JDBC支持 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-jdbc</artifactId>
        </dependency>
        
        <!-- PostgreSQL驱动 -->
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>
        
        <!-- PgVector向量存储 -->
        <dependency>
            <groupId>org.springframework.ai</groupId>
            <artifactId>spring-ai-pgvector-store</artifactId>
            <version>1.0.0-M6</version>
        </dependency>
        
        <!-- Knife4j API文档 -->
        <dependency>
            <groupId>com.github.xiaoymin</groupId>
            <artifactId>knife4j-openapi3-jakarta-spring-boot-starter</artifactId>
            <version>4.4.0</version>
        </dependency>
        
        <!-- 阿里云通义千问 -->
        <dependency>
            <groupId>com.alibaba.cloud.ai</groupId>
            <artifactId>spring-ai-alibaba-starter</artifactId>
            <version>1.0.0-M6.1</version>
        </dependency>
        
        <!-- JSON Schema生成器 -->
        <dependency>
            <groupId>com.github.victools</groupId>
            <artifactId>jsonschema-generator</artifactId>
            <version>4.38.0</version>
        </dependency>
        
        <!-- Lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        
        <!-- Spring Boot Test -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        
        <!-- Kryo序列化 -->
        <dependency>
            <groupId>com.esotericsoftware</groupId>
            <artifactId>kryo</artifactId>
            <version>5.6.2</version>
        </dependency>
        
        <!-- Markdown文档支持 -->
        <dependency>
            <groupId>org.springframework.ai</groupId>
            <artifactId>spring-ai-markdown-document-reader</artifactId>
            <version>1.0.0-M6</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <configuration>
                    <annotationProcessorPaths>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

------

## 🎯 总结

现在你拥有了完整的扩展功能实现代码：

### ✅ 已实现的功能

1. **邮件发送工具** - 支持文本邮件、HTML邮件、带附件邮件
2. **时间工具** - 获取当前时间、日期计算、时间戳转换等
3. **数据库操作工具** - 安全的数据库查询、表信息查看、记录统计
4. **PDF生成优化** - 支持OSS上传和本地Web访问两种方案
5. **工具执行日志** - AOP拦截、数据库记录、统计分析
6. **PDF解析工具** - 文本提取、分页解析、向量化存储

### 📋 实施步骤

1. **添加依赖** - 将新的依赖添加到 pom.xml
2. **创建工具类** - 复制上述工具类代码到项目中
3. **配置参数** - 在 application.yml 中添加必要配置
4. **注册工具** - 更新 ToolRegistration.java
5. **创建数据库表** - 执行SQL创建日志表
6. **测试功能** - 启动应用并测试各个工具

所有代码都包含详细的中文注释，每一行都解释了其作用，方便你理解和维护！