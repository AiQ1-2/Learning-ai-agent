# Spring AI 工具扩展功能实现思路

## 1. 邮件发送工具

### 实现思路
使用 Spring Boot Mail 实现邮件发送功能，支持简单文本、HTML 和附件三种模式。

### 关键步骤
1. 添加依赖：`spring-boot-starter-mail`
2. 配置 SMTP 服务器信息（以 QQ 邮箱为例）
3. 创建工具类，注入 `JavaMailSender`

### 核心代码
```java
@Tool(description = "Send a simple text email to specified recipient")
public String sendSimpleEmail(String to, String subject, String content) {
    SimpleMailMessage message = new SimpleMailMessage();
    message.setFrom(fromEmail);
    message.setTo(to);
    message.setSubject(subject);
    message.setText(content);
    mailSender.send(message);
    return "Email sent successfully to: " + to;
}
```

---

## 2. 时间工具

### 实现思路
基于 Java 8 的 `java.time` 包实现时间日期操作，无需额外依赖。

### 功能点
- 获取当前日期时间（支持自定义格式）
- 计算日期/时间差
- 日期加减运算
- 时间戳转换

### 核心代码
```java
@Tool(description = "Get current date and time in specified format")
public String getCurrentDateTime(String format) {
    LocalDateTime now = LocalDateTime.now();
    DateTimeFormatter formatter = DateTimeFormatter.ofPattern(format);
    return now.format(formatter);
}

@Tool(description = "Calculate the number of days between two dates")
public String calculateDaysBetween(String startDate, String endDate) {
    LocalDate start = LocalDate.parse(startDate);
    LocalDate end = LocalDate.parse(endDate);
    long days = ChronoUnit.DAYS.between(start, end);
    return "Days between: " + days;
}
```

---

## 3. 数据库操作工具

### 实现思路
使用 `JdbcTemplate` 执行数据库查询，重点关注安全性（仅允许 SELECT 操作）。

### 安全措施
- 正则表达式检测危险 SQL 关键字（DROP、DELETE、UPDATE 等）
- 仅允许 SELECT 查询
- 支持参数化查询防止 SQL 注入

### 核心代码
```java
// SQL 注入检测
private static final Pattern DANGEROUS_PATTERN = Pattern.compile(
    ".*(DROP|DELETE|UPDATE|INSERT|ALTER|CREATE|TRUNCATE|EXEC|EXECUTE).*",
    Pattern.CASE_INSENSITIVE
);

@Tool(description = "Execute a SELECT query on the database")
public String executeQuery(String sql) {
    if (!isSafeSql(sql) || !sql.trim().toUpperCase().startsWith("SELECT")) {
        return "Error: Only SELECT queries are allowed.";
    }
    List<Map<String, Object>> results = jdbcTemplate.queryForList(sql);
    return objectMapper.writeValueAsString(results);
}
```

---

## 4. PDF 生成工具优化

### 方案 A：阿里云 OSS（推荐）

#### 实现思路
1. 本地生成 PDF 到临时目录
2. 上传到阿里云 OSS
3. 返回可访问的 URL
4. 清理本地临时文件

#### 关键代码
```java
@Tool(description = "Generate PDF and upload to cloud storage")
public String generatePDFWithURL(String fileName, String content) {
    // 1. 生成 PDF 到临时目录
    String tempFilePath = tempDir + "/" + fileName;
    try (PdfWriter writer = new PdfWriter(tempFilePath);
         PdfDocument pdf = new PdfDocument(writer);
         Document document = new Document(pdf)) {
        document.add(new Paragraph(content));
    }
    
    // 2. 上传到 OSS
    String objectKey = "pdf/" + fileName;
    ossClient.putObject(new PutObjectRequest(bucketName, objectKey, new File(tempFilePath)));
    
    // 3. 生成 URL
    String fileUrl = urlPrefix + objectKey;
    
    // 4. 清理临时文件
    FileUtil.del(tempFilePath);
    
    return "Access URL: " + fileUrl;
}
```

### 方案 B：本地 Web 服务器

#### 实现思路
将 PDF 生成到 `src/main/resources/static/pdf` 目录，Spring Boot 自动提供静态资源访问。

---

## 5. 工具执行日志和控制

### 实现思路
使用 AOP 切面拦截所有 `@Tool` 注解的方法，记录执行日志到数据库。

### 实现步骤

#### 步骤 1：创建日志表
```sql
CREATE TABLE tool_call_logs (
    id SERIAL PRIMARY KEY,
    tool_name VARCHAR(100) NOT NULL,
    parameters TEXT,
    result TEXT,
    execution_time BIGINT,
    status VARCHAR(20) NOT NULL,
    error_message TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

#### 步骤 2：创建 AOP 切面
```java
@Aspect
@Component
public class ToolCallAspect {
    
    @Around("@annotation(org.springframework.ai.tool.annotation.Tool)")
    public Object logToolExecution(ProceedingJoinPoint joinPoint) throws Throwable {
        long startTime = System.nanoTime();
        String toolName = joinPoint.getSignature().getName();
        
        // 获取参数
        Object[] args = joinPoint.getArgs();
        String parametersJson = objectMapper.writeValueAsString(args);
        
        Object result = null;
        String status = "success";
        String errorMessage = null;
        
        try {
            // 执行目标方法
            result = joinPoint.proceed();
        } catch (Throwable e) {
            status = "error";
            errorMessage = e.getMessage();
            throw e;
        } finally {
            // 计算执行时间
            long executionTime = (System.nanoTime() - startTime) / 1_000_000;
            
            // 保存到数据库
            saveLogToDatabase(toolName, parametersJson, result, executionTime, status, errorMessage);
        }
        
        return result;
    }
}
```

#### 步骤 3：创建管理器
```java
@Component
public class ToolExecutionManager {
    
    // 查询最近的工具调用
    public List<Map<String, Object>> getRecentToolCalls(int limit) {
        return jdbcTemplate.queryForList(
            "SELECT * FROM tool_call_logs ORDER BY created_at DESC LIMIT ?", limit);
    }
    
    // 统计工具调用
    public List<Map<String, Object>> getToolCallStatistics() {
        return jdbcTemplate.queryForList(
            "SELECT tool_name, COUNT(*) as total_calls, " +
            "AVG(execution_time) as avg_execution_time " +
            "FROM tool_call_logs GROUP BY tool_name");
    }
}
```

---

## 6. PDF 解析工具

### 实现思路
使用 Apache PDFBox 解析 PDF 文件，提取文本内容并支持向量化存储用于 RAG。

### 功能点
- 提取 PDF 全文
- 提取指定页面
- 文本分块并存储到向量数据库
- 获取 PDF 元信息

### 核心代码

#### 基础解析
```java
@Tool(description = "Parse a PDF file and extract text content")
public String parsePDF(String pdfPath) {
    try (PDDocument document = PDDocument.load(new File(pdfPath))) {
        PDFTextStripper stripper = new PDFTextStripper();
        String text = stripper.getText(document);
        return "Extracted text:\n" + text;
    }
}
```

#### 向量化存储
```java
@Tool(description = "Parse PDF and store in vector database for RAG")
public String parsePDFToVectorStore(String pdfPath, int chunkSize) {
    try (PDDocument document = PDDocument.load(new File(pdfPath))) {
        // 1. 提取文本
        String fullText = new PDFTextStripper().getText(document);
        
        // 2. 文本分块
        List<String> chunks = splitTextIntoChunks(fullText, chunkSize);
        
        // 3. 创建 Document 对象
        List<Document> documents = new ArrayList<>();
        for (int i = 0; i < chunks.size(); i++) {
            Map<String, Object> metadata = Map.of(
                "source", pdfPath,
                "chunk_index", i,
                "total_chunks", chunks.size()
            );
            documents.add(new Document(chunks.get(i), metadata));
        }
        
        // 4. 存储到向量数据库
        vectorStore.add(documents);
        
        return "Stored " + chunks.size() + " chunks in vector database";
    }
}
```

#### 智能分块策略
```java
// 按段落和句子智能分割
private List<String> smartSplitText(String text, int maxChunkSize) {
    List<String> chunks = new ArrayList<>();
    String[] paragraphs = text.split("\n\n");
    
    StringBuilder currentChunk = new StringBuilder();
    for (String paragraph : paragraphs) {
        if (currentChunk.length() + paragraph.length() <= maxChunkSize) {
            currentChunk.append("\n\n").append(paragraph);
        } else {
            chunks.add(currentChunk.toString());
            currentChunk = new StringBuilder(paragraph);
        }
    }
    
    if (currentChunk.length() > 0) {
        chunks.add(currentChunk.toString());
    }
    
    return chunks;
}
```

---

## 7. 工具注册

### 实现思路
在 `ToolRegistration` 配置类中统一注册所有工具，支持条件注入。

### 核心代码
```java
@Configuration
public class ToolRegistration {
    
    @Autowired(required = false)
    private JavaMailSender mailSender;
    
    @Autowired(required = false)
    private OSS ossClient;
    
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    @Autowired
    private VectorStore vectorStore;
    
    @Bean
    public ToolCallback[] allTools() {
        List<Object> tools = new ArrayList<>();
        
        // 基础工具（必需）
        tools.add(new FileOperationTool());
        tools.add(new DateTimeTool());
        tools.add(new DatabaseOperationTool(jdbcTemplate));
        tools.add(new PDFParsingTool(vectorStore));
        
        // 可选工具（根据配置条件注入）
        if (mailSender != null) {
            tools.add(new EmailSendingTool(mailSender));
        }
        
        if (ossClient != null) {
            tools.add(new EnhancedPDFGenerationTool(ossClient));
        }
        
        return ToolCallbacks.from(tools.toArray());
    }
}
```

---

## 8. 配置要点

### application.yml 关键配置
```yaml
spring:
  # 邮件配置
  mail:
    host: smtp.qq.com
    port: 587
    username: your-email@qq.com
    password: your-authorization-code
  
  # 数据源配置
  datasource:
    url: jdbc:postgresql://localhost:5432/your_db
    username: your_user
    password: your_password

# 阿里云 OSS 配置
aliyun:
  oss:
    endpoint: oss-cn-hangzhou.aliyuncs.com
    access-key-id: your-access-key-id
    access-key-secret: your-access-key-secret
    bucket-name: your-bucket-name
    url-prefix: https://your-bucket-name.oss-cn-hangzhou.aliyuncs.com/
```

### pom.xml 关键依赖
```xml
<!-- 邮件 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-mail</artifactId>
</dependency>

<!-- AOP -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>

<!-- PDF 解析 -->
<dependency>
    <groupId>org.apache.pdfbox</groupId>
    <artifactId>pdfbox</artifactId>
    <version>3.0.1</version>
</dependency>

<!-- 阿里云 OSS -->
<dependency>
    <groupId>com.aliyun.oss</groupId>
    <artifactId>aliyun-sdk-oss</artifactId>
    <version>3.17.4</version>
</dependency>
```

---

## 总结

### 实现优先级建议

**第一阶段（基础功能）**
1. 时间工具 - 无依赖，快速实现
2. 数据库操作工具 - 利用现有 JDBC 配置

**第二阶段（增强功能）**
3. 工具执行日志 - 提升可观测性
4. PDF 解析工具 - 增强 RAG 能力

**第三阶段（可选功能）**
5. 邮件发送工具 - 需要邮箱配置
6. PDF 生成优化 - 需要 OSS 配置

### 关键技术点
- **安全性**：数据库工具的 SQL 注入防护
- **可观测性**：AOP 切面实现统一日志记录
- **扩展性**：条件注入支持可选功能
- **实用性**：PDF 解析与向量存储结合支持 RAG
